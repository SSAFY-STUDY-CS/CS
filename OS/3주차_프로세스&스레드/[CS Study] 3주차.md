# [CS Study] 3주차

# [Week 3] 프로세스와 스레드의 핵심 원리 및 비교

## 01. 프로세스(Process): 실행의 주체

### 1.1. 프로세스의 정의와 특징

- **정의:** 실행 파일(Program)이 메모리에 적재되어 CPU에 의해 실행되고 있는 상태
(Program in Execution)를 의미합니다.
- **특징:** 운영체제로부터 독립된 메모리 영역과 자원을 할당받는 최소 작업 단위입니다.
    - 커널에 등록되고 커널의 관리하에 있는 작업.
    - 각종 자원들을 요청하고 할당 받을 수 있는 개체.
    - 프로세스 관리 블록(PCB)을 할당 받은 개체
- **JOB/Program vs Process vs Processor?**
    
    ![image.png](image.png)
    

### 1.2. 프로세스의 메모리 구조

프로세스는 운영체제로부터 독립된 주소 공간을 할당받으며, 이는 크게 4가지 영역으로 나뉩니다.

- **Code(Text) 영역:** 실행할 프로그램의 기계어 명령어가 저장되는 공간 (Read-only).
- **Data 영역:** 전역 변수(Global), 정적 변수(Static)가 저장되는 공간.
- **Heap 영역:** 실행 시간(Runtime)에 동적으로 할당되는 데이터가 저장되는 공간 (malloc, new 등).
- **Stack 영역:** 함수 호출 시 생성되는 지역 변수, 매개변수, 반환 주소 등이 저장되는 공간.
- **특징:** Stack은 위에서 아래로, Heap은 아래에서 위로 쌓이며 메모리를 유연하게 사용합니다.

![image.png](image%201.png)

### 1.3. PCB (Process Control Block)

- **정의:** 운영체제가 각 프로세스를 관리하기 위해 프로세스별 정보를 저장하는 커널 내의 자료구조입니다.
- **주요 정보:** PID(프로세스 식별 번호), 프로세스 상태, PC(Program Counter), 레지스터 값, 스케줄링 정보, 메모리 관리 정보 등.
- **생성 시점:** 프로세스가 생성될 때 만들어지며, 프로세스 종료 시 함께 삭제됩니다.

---

## 02. 프로세스의 상태 관리와 문맥 교환

### 2.1. 프로세스 상태 전이 (State Transition)

프로세스는 실행 과정에서 여러 상태를 거치며 변화합니다.

- **Created (New):** 프로세스가 생성 중이며 PCB를 할당받은 상태.
- **Ready:** CPU를 할당받기 위해 대기 중인 상태 (메모리 적재 완료).
- **Running:** CPU를 점유하여 실제 명령어를 실행 중인 상태.
- **Blocked (Asleep/Wait):** I/O 작업이나 자원 요청 등으로 인해 CPU를 반납하고 기다리는 상태.
- **Terminated (Exit):** 실행이 완료되어 자원을 반납하고 PCB만 남은 상태.

![image.png](image%202.png)

**주요 전이(Transition):**

- **Dispatch:** Ready → Running (스케줄러에 의해 선택됨).
- **Timeout:** Running → Ready (할당된 시간 만료).
- **Wake-up:** Blocked → Ready (기다리던 이벤트 완료).

### 2.2. 문맥 교환 (Context Switching)

- **정의:** CPU가 실행 중인 프로세스를 멈추고 다른 프로세스로 전환할 때, 현재 프로세스의 상태(Context)를 저장하고 새로운 프로세스의 상태를 복구하는 과정입니다.
- **Context:** 프로세스가 재시작될 때 필요한 정보 (주로 레지스터 값, PC 등)를 말하며, 이는 PCB에 저장됩니다.
- **오버헤드(Overhead):** 문맥 교환 중에는 CPU가 실제 유용한 작업을 하지 못하므로, 빈번한 교환은 시스템 성능 저하를 일으킵니다.

---

## 03. 스레드(Thread): 실행의 단위

### 3.1. 스레드의 정의 및 등장 배경

- **정의:** 프로세스 내에서 실행되는 여러 흐름의 단위입니다.
- **배경:** 프로세스 생성 및 문맥 교환의 높은 비용을 줄이고, 프로세스 내 자원을 효율적으로 공유하기 위해 등장했습니다.

![image.png](image%203.png)

### 3.2. 스레드의 메모리 구조 및 TCB

[Image comparing single-threaded and multi-threaded process memory structures]

- **공유 영역:** Code, Data, Heap 영역은 프로세스 내의 모든 스레드가 공유합니다.
- **개별 영역:** 각 스레드는 독립적인 실행 흐름을 위해 **Stack, PC, Registers**를 별도로 가집니다.
    - **Stack을 별도로 가지는 이유:** 독립적인 함수 호출과 실행 흐름을 보장하기 위함입니다.
    - **PC/Registers를 별도로 가지는 이유:** CPU에 의해 스레드가 교체될 때 현재 어디까지 실행했는지 저장해야 하기 때문입니다.
- **TCB (Thread Control Block):** 스레드별 정보를 저장하는 자료구조이며, PCB 내부에 포함되거나 연결되어 관리됩니다.

![image.png](image%204.png)

### 3.3. 스레드의 구현 방식

스레드를 관리하는 주체가 누구냐에 따라 크게 세 가지 모델로 분류됩니다.

### 1) 사용자 수준 스레드 (User-level Threads)

- **정의:** 커널의 도움 없이 사용자 영역의 **스레드 라이브러리**(Pthreads 등)에 의해 관리되는 스레드입니다.
- **특징:**
    - 커널은 이 스레드들의 존재를 모르며, 단일 프로세스로만 인식합니다.
    - **장점:** 모드 전환(User ↔ Kernel) 오버헤드가 없어 생성 및 관리 속도가 매우 빠릅니다.
    - **단점:** 하나의 스레드가 시스템 콜을 호출하여 블록(Block)되면, 프로세스 내의 모든 스레드가 함께 블록됩니다. (커널이 프로세스 단위로 스케줄링하기 때문)
    
    ![image.png](image%205.png)
    

### 2) 커널 수준 스레드 (Kernel-level Threads)

- **정의:** **운영체제(Kernel)**가 직접 스레드의 생성, 스케줄링 및 관리를 담당하는 방식입니다.
- **특징:**
    - 커널이 각 스레드를 개별적으로 인식하고 관리합니다.
    - **장점:** 하나의 스레드가 블록되더라도 다른 스레드는 계속 실행될 수 있습니다. 멀티프로세서 환경에서 여러 스레드를 병렬로 처리하기 유리합니다.
    - **단점:** 스레드 생성 및 전환 시마다 커널 모드 진입이 필요하므로 사용자 수준 스레드보다 오버헤드가 큽니다.
    
    ![image.png](image%206.png)
    

### 3) 혼합형 스레드 (Hybrid/Combined Threads)

- **정의:** 사용자 수준 스레드와 커널 수준 스레드를 혼합한 방식(n:m 매핑)입니다.
- **특징:**
    - 사용자 영역에서 스레드를 생성하고 관리하되, 커널 수준 스레드와 동적으로 바인딩됩니다.
    - **장점:** 사용자 수준의 빠른 속도와 커널 수준의 병렬 실행 능력을 동시에 확보하려 노력한 모델입니다.
    - **단점:** 구현이 매우 복잡하며 스케줄러 간의 통신이 어렵다는 한계가 있습니다.