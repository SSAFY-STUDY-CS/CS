# 지난 번 주제 회고 (정규화 + 이상)

## 이상(삽입/삭제/수정)이란

## 정규화 목적: 중복 제거 + 무결성 강화 이상 방지

## “대신 조회가 불편해짐 → 조인이 등장”

---

# 조인이란?

분해한 정보를 조회 시점에 다시 조립!

- 정규화로 분해한 데이터(테이블)를 **필요한 형태**로 합쳐 조회
- `데이터 설계의 대가`를 치르는 도구

# JOIN 종류

![image.png](attachment:1c14ce37-26ba-424c-b825-14be7f2ac65d:image.png)

![image.png](attachment:930926a3-322e-4286-8be4-f9d3335684b9:image.png)

### 1. INNER JOIN

- 매칭되는 행만 남는다 (교집합)

```sql
SELECT 
	e.emp_id, 
	e.name, 
	s.pay_month, 
	s.amount
FROM employees e
INNER JOIN salaries s
  ON e.emp_id = s.emp_id;
```

- **결과**

| emp_id | name | pay_month | amount |
| --- | --- | --- | --- |
| 1 | 현승 | 2026-01 | 500 |
| 1 | 현승 | 2026-02 | 520 |
| 2 | 민지 | 2026-01 | 480 |

### 2. LEFT JOIN

- 왼쪽은 무조건 유지, 오른쪽은 매칭 실패 시 NULL

```sql
SELECT e.emp_id, e.name, s.pay_month, s.amount
FROM employees e
LEFT JOIN salaries s
  ON e.emp_id = s.emp_id;
```

- **결과**

| emp_id | name | pay_month | amount |
| --- | --- | --- | --- |
| 1 | 현승 | 2026-01 | 500 |
| 1 | 현승 | 2026-02 | 520 |
| 2 | 민지 | 2026-01 | 480 |
| 3 | 철수 | NULL | NULL |

### 3. RIGHT JOIN

- LEFT JOIN의 반대 버전
- 실무에서는 보통 LEFT JOIN으로 통일

```sql
SELECT e.emp_id, e.name, s.pay_month, s.amount
FROM employees e
RIGHT JOIN salaries s
  ON e.emp_id = s.emp_id;
```

```sql
SELECT e.emp_id, e.name, s.pay_month, s.amount
FROM salaries s
LEFT JOIN employees e
  ON e.emp_id = s.emp_id;
```

![image.png](attachment:3059f256-f33e-4e37-86f0-ad125cb9e4d6:image.png)

---

# 조인 함정

### 1. LEFT JOIN + WHERE 함정

- WHERE는 조인 결과에 적용 → 오른쪽 조건을 WHERE에 두면 NULL 행 탈락 → INNER처럼 작용함
    - 좀 더 자세하게 설명하자면 LEFT JOIN을 사용할 때 우리가 조인한 상태에서 WHERE절이 걸린다고 생각하기에 오른쪽 테이블이 왼쪽 테이블하고 연결 안 되도 where절에 걸려 조회될 거라 생각한다? 맞지?
    - 그래서 해결법으로 오른쪽 컬럼 where절에 들어갈 내용을 `LEFT JOIN right_table on left.id = right.left_id or right.name like '현승'` 같은 건가?

### 2. 조인 조건 실수로 행 폭발(카디널리티)

- 1:N을 모르고 붙이면 N:N처럼 늘어날 수 있음 → 이건 카테시안 곱 얘기인가? 예가 필요함
- 조인 결과 행이 원본보다 커질 수 있다? 카테시안 이것도?

### 3. NULL 비교 함정

- `= NULL` ❌
- `IS NULL` 🙆
